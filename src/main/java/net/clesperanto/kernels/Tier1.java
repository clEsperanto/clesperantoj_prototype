/*-
 * #%L
 * Java wrapper for Clesperanto
 * %%
 * Copyright (C) 2022 - 2025 Robert Haase, MPI CBG and Stephane Rigaud, Institut Pasteur
 * %%
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the PoL, TU Dresden nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * #L%
 */

/**
 * This file is autogenerated. Do not edit manually.
 */    
package net.clesperanto.kernels;

import java.util.Objects;
import java.util.ArrayList;
import java.util.HashMap;

import net.clesperanto.core.ArrayJ;
import net.clesperanto.core.DeviceJ;
import net.clesperanto.core.Utils;

/**
 * Class containing all functions of tier 1 category
 */
public class Tier1 {

	/**
	 * Computes the absolute value of every individual pixel x in a given image.
	 * &amp;lt;pre&amp;gt;f(x) = |x| &amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - The input image to be processed.
	 * @param output ({@link ArrayJ}) - Output image where results are written into. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_absolute">reference_absolute</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ absolute(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.absolute(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Calculates the sum of pairs of pixels x and y from images X and Y weighted with factors a and b.
	 * &amp;lt;pre&amp;gt;f(x, y, a, b) = x * a + y * b&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - First input image to add.
	 * @param input1 ({@link ArrayJ}) - Second image to add.
	 * @param output ({@link ArrayJ}) - Output image where results are written into. (default: None)
	 * @param factor1 (float) - Multiplication factor of each pixel of src0 before adding it. (default: 1)
	 * @param factor2 (float) - Multiplication factor of each pixel of src1 before adding it. (default: 1)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_addImagesWeighted">reference_addImagesWeighted</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ addImagesWeighted(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output, float factor1, float factor2) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.add_images_weighted(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw(), factor1, factor2));
    }
    
	/**
	 * Adds a scalar value s to all pixels x of a given image X.
	 * &amp;lt;pre&amp;gt;f(x, s) = x + s&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output image. (default: None)
	 * @param scalar (float) - Scalar number to add to all pixels. (default: 1)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_addImageAndScalar">reference_addImageAndScalar</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ addImageAndScalar(DeviceJ device, ArrayJ input, ArrayJ output, float scalar) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.add_image_and_scalar(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), scalar));
    }
    
	/**
	 * Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of pixels x and y with the binary AND operator &amp;.
	 * All pixel values except 0 in the input images are interpreted as 1.
	 * &amp;lt;pre&amp;gt;f(x, y) = x &amp; y&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - First binary input image to be processed.
	 * @param input1 ({@link ArrayJ}) - Second binary input image to be processed.
	 * @param output ({@link ArrayJ}) - Output image where results are written into. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_binaryAnd">reference_binaryAnd</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ binaryAnd(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.binary_and(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines pixels/voxels which are on the surface of binary objects and sets only them to 1 in the destination image.
	 * All other pixels are set to 0.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Binary input image where edges will be searched.
	 * @param output ({@link ArrayJ}) - Output image where edge pixels will be 1. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_binaryEdgeDetection">reference_binaryEdgeDetection</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ binaryEdgeDetection(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.binary_edge_detection(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes a binary image (containing pixel values 0 and 1) from an image X by negating its pixel values x using the binary NOT operator ! All pixel values except 0 in the input image are interpreted as 1.
	 * &amp;lt;pre&amp;gt;f(x) = !x&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Binary input image to be inverted.
	 * @param output ({@link ArrayJ}) - Output image where results are written into. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_binaryNot">reference_binaryNot</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ binaryNot(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.binary_not(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of pixels x and y with the binary OR operator |.
	 * All pixel values except 0 in the input images are interpreted as 1.
	 * &amp;lt;pre&amp;gt;f(x, y) = x | y&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - First binary input image to be processed.
	 * @param input1 ({@link ArrayJ}) - Second binary input image to be processed.
	 * @param output ({@link ArrayJ}) - Output image where results are written into. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_binaryOr">reference_binaryOr</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ binaryOr(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.binary_or(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Subtracts one binary image from another.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - First binary input image to be processed.
	 * @param input1 ({@link ArrayJ}) - Second binary input image to be subtracted from the first.
	 * @param output ({@link ArrayJ}) - Output image where results are written into. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_binarySubtract">reference_binarySubtract</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ binarySubtract(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.binary_subtract(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of pixels x and y with the binary operators AND &amp;, OR | and NOT ! implementing the XOR operator.
	 * All pixel values except 0 in the input images are interpreted as 1.
	 * &amp;lt;pre&amp;gt;f(x, y) = (x &amp; !y) | (!x &amp; y)&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - First binary input image to be processed.
	 * @param input1 ({@link ArrayJ}) - Second binary input image to be processed.
	 * @param output ({@link ArrayJ}) - Output image where results are written into. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_binaryXOr">reference_binaryXOr</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ binaryXor(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.binary_xor(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Compute the maximum of the erosion with plannar structuring elements.
	 * Warning: This operation is only supported BINARY data type images.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - The binary input image to be processed.
	 * @param output ({@link ArrayJ}) - Output image where results are written into. (default: None)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ binarySupinf(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.binary_supinf(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Compute the minimum of the dilation with plannar structuring elements.
	 * Warning: This operation is only supported BINARY data type images.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - The binary input image to be processed.
	 * @param output ({@link ArrayJ}) - Output image where results are written into. (default: None)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ binaryInfsup(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.binary_infsup(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Enumerates pixels with value 1 in a onedimensional image For example handing over the image [0, 1, 1, 0, 1, 0, 1, 1] would be processed to an image [0, 1, 2, 0, 3, 0, 4, 5] This functionality is important in connected component neccessary (see also sum_reduction_x).
	 * In the above example, with blocksize 4, that would be the sum array: [2, 3] labeling.
	 * Processing is accelerated by paralellization in blocks.
	 * Therefore, handing over precomputed block sums is Note that the block size when calling this function and sum_reduction must be identical.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - input binary vector image
	 * @param input1 ({@link ArrayJ}) - precomputed sums of blocks
	 * @param output ({@link ArrayJ}) - output enumerated vector image (default: None)
	 * @param blocksize (int) -  (default: 256)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ blockEnumerate(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output, int blocksize) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.block_enumerate(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw(), blocksize));
    }
    
	/**
	 * Convolve the image with a given kernel image.
	 * It is recommended that the kernel image has an odd size in X, Y and Z.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - First input image to process.
	 * @param input1 ({@link ArrayJ}) - Second input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_convolve">reference_convolve</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ convolve(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.convolve(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Copies an image.
	 * &amp;lt;pre&amp;gt;f(x) = x&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to copy.
	 * @param output ({@link ArrayJ}) - Output copy image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_copy">reference_copy</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ copy(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.copy(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * This method has two purposes: It copies a 2D image to a given slice_index z position in a 3D image stack or It copies a given slice_index at position z in an image stack to a 2D image.
	 * The first case is only available via ImageJ macro.
	 * If you are using it, it is recommended that the target 3D image already preexists in GPU memory before calling this method.
	 * Otherwise, CLIJ create the image stack with z planes.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to copy from.
	 * @param output ({@link ArrayJ}) - Output copy image slice_index. (default: None)
	 * @param slice_index (int) - Index of the slice to copy. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_copySlice">reference_copySlice</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ copySlice(DeviceJ device, ArrayJ input, ArrayJ output, int slice_index) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.copy_slice(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), slice_index));
    }
    
	/**
	 * This method has two purposes: It copies a 2D image to a given slice_index y position in a 3D image stack or It copies a given slice_index at position y in an image stack to a 2D image.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to copy from.
	 * @param output ({@link ArrayJ}) - Output copy image slice_index. (default: None)
	 * @param slice_index (int) - Index of the slice to copy. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_copySlice">reference_copySlice</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ copyHorizontalSlice(DeviceJ device, ArrayJ input, ArrayJ output, int slice_index) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.copy_horizontal_slice(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), slice_index));
    }
    
	/**
	 * This method has two purposes: It copies a 2D image to a given slice_index x position in a 3D image stack or It copies a given slice_index at position x in an image stack to a 2D image.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to copy from.
	 * @param output ({@link ArrayJ}) - Output copy image slice_index. (default: None)
	 * @param slice_index (int) - Index of the slice to copy. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_copySlice">reference_copySlice</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ copyVerticalSlice(DeviceJ device, ArrayJ input, ArrayJ output, int slice_index) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.copy_vertical_slice(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), slice_index));
    }
    
	/**
	 * Crops a given substack out of a given image stack.
	 * Note: If the destination image preexists already, it will be overwritten and keep it's dimensions.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param start_x (int) - Starting index coordicante x. (default: 0)
	 * @param start_y (int) - Starting index coordicante y. (default: 0)
	 * @param start_z (int) - Starting index coordicante z. (default: 0)
	 * @param width (int) - Width size of the region to crop. (default: 1)
	 * @param height (int) - Height size of the region to crop. (default: 1)
	 * @param depth (int) - Depth size of the region to crop. (default: 1)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_crop3D">reference_crop3D</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ crop(DeviceJ device, ArrayJ input, ArrayJ output, int start_x, int start_y, int start_z, int width, int height, int depth) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.crop(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), start_x, start_y, start_z, width, height, depth));
    }
    
	/**
	 * Computes the cubic root of each pixel.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ cubicRoot(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.cubic_root(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Takes a labelmap and returns an image where all pixels on label edges are set to 1 and all other pixels to 0.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_detectLabelEdges">reference_detectLabelEdges</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ detectLabelEdges(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.detect_label_edges(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes the dilation operation between an image and a structuring element.
	 * The operation is applied in grayscale if the image is in grayscale.
	 * The structuring element is a binary image with pixel values 0 and 1, and must have the same dimensionality as the image (3D is the image is 3D, 2D if the image is 2D).
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param footprint ({@link ArrayJ}) - Structuring element to use for the operation.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_erodeBox">reference_erodeBox</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ dilation(DeviceJ device, ArrayJ input, ArrayJ footprint, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
		Objects.requireNonNull(footprint, "footprint cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.dilation(device.getRaw(), input.getRaw(), footprint.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.
	 * The dilation takes the Moore neighborhood (8 pixels in 2D and 26 pixels in 3d) into account.
	 * The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.
	 * This method is comparable to the 'Dilate' menu in ImageJ in case it is applied to a 2D image.
	 * The only difference is that the output image contains values 0 and 1 instead of 0 and 255.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process. Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_dilateBox">reference_dilateBox</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ dilateBox(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.dilate_box(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.
	 * The dilation takes the von Neumann neighborhood (4 pixels in 2D and 6 pixels in 3d) into account.
	 * The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process. Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_dilateSphere">reference_dilateSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ dilateSphere(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.dilate_sphere(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.
	 * The dilation apply the Moore neighborhood (8 pixels in 2D and 26 pixels in 3d) for the "box" connectivity and the von Neumann neighborhood (4 pixels in 2D and 6 pixels in 3d) for a "sphere" connectivity.
	 * The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.
	 * For a more flexible dilation with arbitrary shapes, use dilation() instead.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process. Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. Output result image. (default: None)
	 * @param radius_x (float) - Radius of sphere or box structuring element in X. (default: 1)
	 * @param radius_y (float) - Radius of sphere or box structuring element in Y. (default: 1)
	 * @param radius_z (float) - Radius of sphere or box structuring element in Z. (default: 1)
	 * @param connectivity (String) - Element shape, "box" or "sphere". (default: "box")
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_dilateBox">reference_dilateBox</a>
	 * @see <a href="https://clij.github.io/clij2-docs/reference_dilateSphere">reference_dilateSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ binaryDilate(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.binary_dilate(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z, connectivity));
    }
    
	/**
	 * Divides two images X and Y by each other pixel wise.
	 * &amp;lt;pre&amp;gt;f(x, y) = x / y&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param dividend ({@link ArrayJ}) - Input image to process.
	 * @param divisor ({@link ArrayJ}) - Second input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_divideImages">reference_divideImages</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ divideImages(DeviceJ device, ArrayJ dividend, ArrayJ divisor, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(dividend, "dividend cannot be null");
		Objects.requireNonNull(divisor, "divisor cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.divide_images(device.getRaw(), dividend.getRaw(), divisor.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Divides a scalar by an image pixel by pixel.
	 * &amp;lt;pre&amp;gt;f(x, s) = s / x&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param scalar (float) - Scalar value to divide the image with. (default: 0)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ divideScalarByImage(DeviceJ device, ArrayJ input, ArrayJ output, float scalar) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.divide_scalar_by_image(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), scalar));
    }
    
	/**
	 * Determines if two images A and B equal pixel wise.
	 * &amp;lt;pre&amp;gt;f(a, b) = 1 if a == b; 0 otherwise.
	 * &amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - First image to be compared with.
	 * @param input1 ({@link ArrayJ}) - Second image to be compared with the first.
	 * @param output ({@link ArrayJ}) - Output binary image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_equal">reference_equal</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ equal(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.equal(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines if an image A and a constant b are equal.
	 * &amp;lt;pre&amp;gt;f(a, b) = 1 if a == b; 0 otherwise.
	 * &amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input omage where every pixel is compared to the constant.
	 * @param output ({@link ArrayJ}) - Output binary image. (default: None)
	 * @param scalar (float) - Scalar value to compare pixel with. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_equalConstant">reference_equalConstant</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ equalConstant(DeviceJ device, ArrayJ input, ArrayJ output, float scalar) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.equal_constant(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), scalar));
    }
    
	/**
	 * Computes the erosion operation between an image and a structuring element.
	 * The operation is applied in grayscale if the image is in grayscale.
	 * The structuring element is a binary image with pixel values 0 and 1, and must have the same dimensionality as the image (3D is the image is 3D, 2D if the image is 2D).
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param footprint ({@link ArrayJ}) - Structuring element to use for the operation.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_erodeBox">reference_erodeBox</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ erosion(DeviceJ device, ArrayJ input, ArrayJ footprint, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
		Objects.requireNonNull(footprint, "footprint cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.erosion(device.getRaw(), input.getRaw(), footprint.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image.
	 * The erosion takes the Moore neighborhood (8 pixels in 2D and 26 pixels in 3d) into account.
	 * The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.
	 * This method is comparable to the 'Erode' menu in ImageJ in case it is applied to a 2D image.
	 * The only difference is that the output image contains values 0 and 1 instead of 0 and 255.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_erodeBox">reference_erodeBox</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ erodeBox(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.erode_box(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image.
	 * The erosion takes the von Neumann neighborhood (4 pixels in 2D and 6 pixels in 3d) into account.
	 * The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_erodeSphere">reference_erodeSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ erodeSphere(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.erode_sphere(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image.
	 * The erosion apply the Moore neighborhood (8 pixels in 2D and 26 pixels in 3d) for the "box" connectivity and the von Neumann neighborhood (4 pixels in 2D and 6 pixels in 3d) for a "sphere" connectivity.
	 * The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.
	 * For a more flexible erosion with arbitrary shapes, use erosion() instead.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius of the eroding sphere or box structuring element in X. (default: 1)
	 * @param radius_y (float) - Radius of the eroding sphere or box structuring element in Y. (default: 1)
	 * @param radius_z (float) - Radius of the eroding sphere or box structuring element in Z. (default: 1)
	 * @param connectivity (String) - Element shape, "box" or "sphere". (default: "box")
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_erodeBox">reference_erodeBox</a>
	 * @see <a href="https://clij.github.io/clij2-docs/reference_erodeSphere">reference_erodeSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ binaryErode(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.binary_erode(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z, connectivity));
    }
    
	/**
	 * Computes base exponential of all pixels values.
	 * f(x) = exp(x) Author(s): Peter Haub, Robert Haase.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_exponential">reference_exponential</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ exponential(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.exponential(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Flips an image in X, Y and/or Z direction depending on boolean flags.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param flip_x (boolean) - Flip along the x axis if true. (default: True)
	 * @param flip_y (boolean) - Flip along the y axis if true. (default: True)
	 * @param flip_z (boolean) - Flip along the z axis if true. (default: True)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_flip3D">reference_flip3D</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ flip(DeviceJ device, ArrayJ input, ArrayJ output, boolean flip_x, boolean flip_y, boolean flip_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.flip(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), flip_x, flip_y, flip_z));
    }
    
	/**
	 * Computes the Gaussian blurred image of an image given sigma values in X, Y and Z.
	 * Thus, the filter kernel can have nonisotropic shape.
	 * The implementation is done separable.
	 * In case a sigma equals zero, the direction is not blurred.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param sigma_x (float) - Sigma value along the x axis. (default: 0)
	 * @param sigma_y (float) - Sigma value along the y axis. (default: 0)
	 * @param sigma_z (float) - Sigma value along the z axis. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_gaussianBlur3D">reference_gaussianBlur3D</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ gaussianBlur(DeviceJ device, ArrayJ input, ArrayJ output, float sigma_x, float sigma_y, float sigma_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.gaussian_blur(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), sigma_x, sigma_y, sigma_z));
    }
    
	/**
	 * Computes the distance between all point coordinates given in two point lists.
	 * Takes two images containing pointlists (dimensionality n * d, n: number of points and d: dimensionality) and builds up a matrix containing the distances between these points.
	 * Convention: Given two point lists with dimensionality n * d and m * d, the distance matrix will be of size(n + 1) * (m + 1).
	 * The first row and column contain zeros.
	 * They represent the distance of the (see generateTouchMatrix).
	 * Thus, one can threshold a distance matrix to generate a touch matrix out of it for drawing objects to a theoretical background object.
	 * In that way, distance matrices are of the same size as touch matrices meshes.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param coordinate_list1 ({@link ArrayJ}) - First coordinate list to process.
	 * @param coordinate_list2 ({@link ArrayJ}) - Second coordinate list to process.
	 * @param distance_matrix_destination ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_generateDistanceMatrix">reference_generateDistanceMatrix</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ generateDistanceMatrix(DeviceJ device, ArrayJ coordinate_list1, ArrayJ coordinate_list2, ArrayJ distance_matrix_destination) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(coordinate_list1, "coordinate_list1 cannot be null");
		Objects.requireNonNull(coordinate_list2, "coordinate_list2 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.generate_distance_matrix(device.getRaw(), coordinate_list1.getRaw(), coordinate_list2.getRaw(), distance_matrix_destination == null ? null : distance_matrix_destination.getRaw()));
    }
    
	/**
	 * Computes the gradient of gray values along X.
	 * Assuming a, b and c are three adjacent pixels in X direction.
	 * In the target image will be saved as: &amp;lt;pre&amp;gt;b' = c a;&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_gradientX">reference_gradientX</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ gradientX(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.gradient_x(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes the gradient of gray values along Y.
	 * Assuming a, b and c are three adjacent pixels in Y direction.
	 * In the target image will be saved as: &amp;lt;pre&amp;gt;b' = c a;&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_gradientY">reference_gradientY</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ gradientY(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.gradient_y(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes the gradient of gray values along Z.
	 * Assuming a, b and c are three adjacent pixels in Z direction.
	 * In the target image will be saved as: &amp;lt;pre&amp;gt;b' = c a;&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_gradientZ">reference_gradientZ</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ gradientZ(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.gradient_z(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines if two images A and B greater pixel wise.
	 * f(a, b) = 1 if a &amp;gt; b; 0 otherwise.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - First input image to process.
	 * @param input1 ({@link ArrayJ}) - Second input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_greater">reference_greater</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ greater(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.greater(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines if two images A and B greater pixel wise.
	 * f(a, b) = 1 if a &amp;gt; b; 0 otherwise.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param scalar (float) - Scalar value to compare pixel with. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_greaterConstant">reference_greaterConstant</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ greaterConstant(DeviceJ device, ArrayJ input, ArrayJ output, float scalar) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.greater_constant(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), scalar));
    }
    
	/**
	 * Determines if two images A and B greater or equal pixel wise.
	 * f(a, b) = 1 if a &amp;gt;= b; 0 otherwise.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - First input image to process.
	 * @param input1 ({@link ArrayJ}) - Second input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_greaterOrEqual">reference_greaterOrEqual</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ greaterOrEqual(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.greater_or_equal(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines if two images A and B greater or equal pixel wise.
	 * f(a, b) = 1 if a &amp;gt;= b; 0 otherwise.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param scalar (float) - Scalar value to compare pixel with. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_greaterOrEqualConstant">reference_greaterOrEqualConstant</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ greaterOrEqualConstant(DeviceJ device, ArrayJ input, ArrayJ output, float scalar) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.greater_or_equal_constant(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), scalar));
    }
    
	/**
	 * Computes the eigenvalues of the hessian matrix of a 2d or 3d image.
	 * Hessian matrix or 2D images: [Ixx, Ixy] [Ixy, Iyy] Hessian matrix for 3D images: [Ixx, Ixy, Ixz] [Ixy, Iyy, Iyz] [Ixz, Iyz, Izz] Ixx denotes the second derivative in x.
	 * Ixx and Iyy are calculated by convolving the image with the 1d kernel [1 2 1].
	 * Ixy is calculated by a convolution with the 2d kernel: [ 0.
	 * 25 0 0.
	 * 25] [ 0 0 0] [0.
	 * 25 0 0.
	 * 25] Note: This is the only clesperanto function that returns multiple images.
	 * This API might be subject to change in the future.
	 * Consider using small_hessian_eigenvalue() and/or large_hessian_eigenvalue() instead which return only one image.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param small_eigenvalue ({@link ArrayJ}) - Output result image. (default: None)
	 * @param middle_eigenvalue ({@link ArrayJ}) - Output result image, null if input is 2D. (default: None)
	 * @param large_eigenvalue ({@link ArrayJ}) - Output result image. (default: None)
	 * @return ArrayList&amp;lt;{@link ArrayJ}&amp;gt;
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayList<ArrayJ> hessianEigenvalues(DeviceJ device, ArrayJ input, ArrayJ small_eigenvalue, ArrayJ middle_eigenvalue, ArrayJ large_eigenvalue) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return Utils.toArrayList(net.clesperanto._internals.kernelj.Tier1.hessian_eigenvalues(device.getRaw(), input.getRaw(), small_eigenvalue == null ? null : small_eigenvalue.getRaw(), middle_eigenvalue == null ? null : middle_eigenvalue.getRaw(), large_eigenvalue == null ? null : large_eigenvalue.getRaw()));
    }
    
	/**
	 * Applies the Laplace operator (Box neighborhood) to an image.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_laplaceBox">reference_laplaceBox</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ laplaceBox(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.laplace_box(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Applies the Laplace operator (Diamond neighborhood) to an image.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_laplaceDiamond">reference_laplaceDiamond</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ laplaceDiamond(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.laplace_diamond(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Applies the Laplace operator with a "box" or a "sphere" neighborhood to an image.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param connectivity (String) - Filter neigborhood (default: "box")
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_laplaceDiamond">reference_laplaceDiamond</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ laplace(DeviceJ device, ArrayJ input, ArrayJ output, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.laplace(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), connectivity));
    }
    
	/**
	 * Compute the cross correlation of an image to a given kernel.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param kernel ({@link ArrayJ}) - Input
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ localCrossCorrelation(DeviceJ device, ArrayJ input, ArrayJ kernel, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
		Objects.requireNonNull(kernel, "kernel cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.local_cross_correlation(device.getRaw(), input.getRaw(), kernel.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes base e logarithm of all pixels values.
	 * f(x) = log(x) Author(s): Peter Haub, Robert Haase.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_logarithm">reference_logarithm</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ logarithm(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.logarithm(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes a masked image by applying a binary mask to an image.
	 * All pixel values x of image X will be copied to the destination image in case pixel value m at the same position in the mask image is not equal to zero.
	 * &amp;lt;pre&amp;gt;f(x,m) = (x if (m != 0); (0 otherwise))&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param mask ({@link ArrayJ}) - Mask image to apply.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_mask">reference_mask</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ mask(DeviceJ device, ArrayJ input, ArrayJ mask, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
		Objects.requireNonNull(mask, "mask cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.mask(device.getRaw(), input.getRaw(), mask.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes a masked image by applying a label mask to an image.
	 * All pixel values x of image X will be copied to the destination image in case pixel value m at the same position in the label_map image has the right index value i.
	 * &amp;lt;pre&amp;gt;f(x,m,i) = (x if (m == i); (0 otherwise))&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - Input Intensity image.
	 * @param input1 ({@link ArrayJ}) - Input Label image.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param label (float) - Label value to use. (default: 1)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_maskLabel">reference_maskLabel</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ maskLabel(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output, float label) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.mask_label(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw(), label));
    }
    
	/**
	 * Computes the maximum of a constant scalar s and each pixel value x in a given image X.
	 * &amp;lt;pre&amp;gt;f(x, s) = max(x, s)&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param scalar (float) - Scalar value used in the comparison. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_maximumImageAndScalar">reference_maximumImageAndScalar</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ maximumImageAndScalar(DeviceJ device, ArrayJ input, ArrayJ output, float scalar) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.maximum_image_and_scalar(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), scalar));
    }
    
	/**
	 * Computes the maximum of a pair of pixel values x, y from two given images X and Y.
	 * &amp;lt;pre&amp;gt;f(x, y) = max(x, y)&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - First input image to process.
	 * @param input1 ({@link ArrayJ}) - Second input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_maximumImages">reference_maximumImages</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ maximumImages(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.maximum_images(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes the local maximum of a pixels cube neighborhood.
	 * The cubes size is specified by its halfwidth, halfheight and halfdepth (radius).
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius size along x axis. (default: 1)
	 * @param radius_y (float) - Radius size along y axis. (default: 1)
	 * @param radius_z (float) - Radius size along z axis. (default: 1)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_maximum3DBox">reference_maximum3DBox</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ maximumBox(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.maximum_box(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Computes the local maximum of a pixels neighborhood (box or sphere).
	 * The neighborhood size is specified by its halfwidth, halfheight and halfdepth (radius).
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius size along x axis. (default: 1)
	 * @param radius_y (float) - Radius size along y axis. (default: 1)
	 * @param radius_z (float) - Radius size along z axis. (default: 1)
	 * @param connectivity (String) - Filter neigborhood (default: "box")
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_maximum3DBox">reference_maximum3DBox</a>
	 * @see <a href="https://clij.github.io/clij2-docs/reference_maximum3DSphere">reference_maximum3DSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ maximumFilter(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.maximum_filter(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z, connectivity));
    }
    
	/**
	 * Computes a grayscale image containing the grayscale dilation of a given input image.
	 * The erosion apply the Moore neighborhood (8 pixels in 2D and 26 pixels in 3d) for the "box" connectivity and the von Neumann neighborhood (4 pixels in 2D and 6 pixels in 3d) for a "sphere" connectivity.
	 * The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius size along x axis. (default: 1)
	 * @param radius_y (float) - Radius size along y axis. (default: 1)
	 * @param radius_z (float) - Radius size along z axis. (default: 1)
	 * @param connectivity (String) - Filter neigborhood (default: "box")
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_minimum3DBox">reference_minimum3DBox</a>
	 * @see <a href="https://clij.github.io/clij2-docs/reference_minimum3DSphere">reference_minimum3DSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ grayscaleDilate(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.grayscale_dilate(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z, connectivity));
    }
    
	/**
	 * Determines the maximum intensity projection of an image along X.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_maximumXProjection">reference_maximumXProjection</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ maximumXProjection(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.maximum_x_projection(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines the maximum intensity projection of an image along X.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_maximumYProjection">reference_maximumYProjection</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ maximumYProjection(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.maximum_y_projection(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines the maximum intensity projection of an image along Z.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_maximumZProjection">reference_maximumZProjection</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ maximumZProjection(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.maximum_z_projection(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes the local mean average of a pixels boxshaped neighborhood.
	 * The cubes size is specified by its halfwidth, halfheight and halfdepth (radius).
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius size along x axis. (default: 1)
	 * @param radius_y (float) - Radius size along y axis. (default: 1)
	 * @param radius_z (float) - Radius size along z axis. (default: 1)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_mean3DBox">reference_mean3DBox</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ meanBox(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.mean_box(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Computes the local mean average of a pixels spherical neighborhood.
	 * The spheres size is specified by its halfwidth, halfheight and halfdepth (radius).
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius size along x axis. (default: 1)
	 * @param radius_y (float) - Radius size along y axis. (default: 1)
	 * @param radius_z (float) - Radius size along z axis. (default: 1)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_mean3DSphere">reference_mean3DSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ meanSphere(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.mean_sphere(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Computes the local mean average of a pixels neighborhood defined as a boxshaped or a sphereshaped.
	 * The shape size is specified by its halfwidth, halfheight and halfdepth (radius).
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius size along x axis. (default: 1)
	 * @param radius_y (float) - Radius size along y axis. (default: 1)
	 * @param radius_z (float) - Radius size along z axis. (default: 1)
	 * @param connectivity (String) - Filter neigborhood (default: "box")
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_mean3DSphere">reference_mean3DSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ meanFilter(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.mean_filter(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z, connectivity));
    }
    
	/**
	 * Determines the mean average intensity projection of an image along X.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_meanXProjection">reference_meanXProjection</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ meanXProjection(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.mean_x_projection(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines the mean average intensity projection of an image along Y.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_meanYProjection">reference_meanYProjection</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ meanYProjection(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.mean_y_projection(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines the mean average intensity projection of an image along Z.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_meanZProjection">reference_meanZProjection</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ meanZProjection(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.mean_z_projection(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes the local median of a pixels box shaped neighborhood.
	 * The box is specified by its halfwidth and halfheight (radius).
	 * For technical reasons, the area of the box must have less than 1000 pixels.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius size along x axis. (default: 1)
	 * @param radius_y (float) - Radius size along y axis. (default: 1)
	 * @param radius_z (float) - Radius size along z axis. (default: 1)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_median3DBox">reference_median3DBox</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ medianBox(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.median_box(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Computes the local median of a pixels sphere shaped neighborhood.
	 * The sphere is specified by its halfwidth and halfheight (radius).
	 * For technical reasons, the area of the box must have less than 1000 pixels.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius size along x axis. (default: 1)
	 * @param radius_y (float) - Radius size along y axis. (default: 1)
	 * @param radius_z (float) - Radius size along z axis. (default: 1)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_median3DSphere">reference_median3DSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ medianSphere(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.median_sphere(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Computes the local median of a pixels neighborhood.
	 * The neighborhood is defined as a box or a sphere shape.
	 * Its size is specified by its halfwidth, halfheight, and halfdepth (radius).
	 * For technical reasons, the area of the shpae must have less than 1000 pixels.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius size along x axis. (default: 1)
	 * @param radius_y (float) - Radius size along y axis. (default: 1)
	 * @param radius_z (float) - Radius size along z axis. (default: 1)
	 * @param connectivity (String) - Filter neigborhood (default: "box")
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_median3DSphere">reference_median3DSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ median(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.median(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z, connectivity));
    }
    
	/**
	 * Computes the local minimum of a pixels cube neighborhood.
	 * The cubes size is specified by its halfwidth, halfheight and halfdepth (radius).
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius size along x axis. (default: 1)
	 * @param radius_y (float) - Radius size along y axis. (default: 1)
	 * @param radius_z (float) - Radius size along z axis. (default: 1)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_minimum3DBox">reference_minimum3DBox</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ minimumBox(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.minimum_box(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Computes the local minimum of a pixels cube neighborhood.
	 * The cubes size is specified by its halfwidth, halfheight and halfdepth (radius).
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius size along x axis. (default: 1)
	 * @param radius_y (float) - Radius size along y axis. (default: 1)
	 * @param radius_z (float) - Radius size along z axis. (default: 1)
	 * @param connectivity (String) - Filter neigborhood (default: "box")
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_minimum3DBox">reference_minimum3DBox</a>
	 * @see <a href="https://clij.github.io/clij2-docs/reference_minimum3DSphere">reference_minimum3DSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ minimumFilter(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.minimum_filter(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z, connectivity));
    }
    
	/**
	 * Computes a grayscale image containing the grayscale erosion of a given input image.
	 * The erosion apply the Mooreneighborhood (8 pixels in 2D and 26 pixels in 3d) for the "box" connectivity and the vonNeumannneighborhood (4 pixels in 2D and 6 pixels in 3d) for a "sphere" connectivity.
	 * The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius size along x axis. (default: 1)
	 * @param radius_y (float) - Radius size along y axis. (default: 1)
	 * @param radius_z (float) - Radius size along z axis. (default: 1)
	 * @param connectivity (String) - Filter neigborhood (default: "box")
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_minimum3DBox">reference_minimum3DBox</a>
	 * @see <a href="https://clij.github.io/clij2-docs/reference_minimum3DSphere">reference_minimum3DSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ grayscaleErode(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.grayscale_erode(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z, connectivity));
    }
    
	/**
	 * Computes the minimum of a constant scalar s and each pixel value x in a given image X.
	 * &amp;lt;pre&amp;gt;f(x, s) = min(x, s)&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param scalar (float) - Scalar value used in the comparison. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_minimumImageAndScalar">reference_minimumImageAndScalar</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ minimumImageAndScalar(DeviceJ device, ArrayJ input, ArrayJ output, float scalar) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.minimum_image_and_scalar(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), scalar));
    }
    
	/**
	 * Computes the minimum of a pair of pixel values x, y from two given images X and Y.
	 * &amp;lt;pre&amp;gt;f(x, y) = min(x, y)&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - First input image to process.
	 * @param input1 ({@link ArrayJ}) - Second input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_minimumImages">reference_minimumImages</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ minimumImages(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.minimum_images(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines the minimum intensity projection of an image along Y.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_minimumXProjection">reference_minimumXProjection</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ minimumXProjection(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.minimum_x_projection(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines the minimum intensity projection of an image along Y.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_minimumYProjection">reference_minimumYProjection</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ minimumYProjection(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.minimum_y_projection(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines the minimum intensity projection of an image along Z.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_minimumZProjection">reference_minimumZProjection</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ minimumZProjection(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.minimum_z_projection(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes the local mode of a pixels box shaped neighborhood.
	 * This can be used to postprocess and locally correct semantic segmentation results.
	 * The box is specified by its halfwidth and halfheight (radius).
	 * For technical reasons, the intensities must lie within a range from 0 to 255.
	 * In case multiple values have maximum frequency, the smallest one is returned.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius size along x axis. (default: 1)
	 * @param radius_y (float) - Radius size along y axis. (default: 1)
	 * @param radius_z (float) - Radius size along z axis. (default: 1)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ modeBox(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.mode_box(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Computes the local mode of a pixels sphere shaped neighborhood.
	 * This can be used to postprocess and locally correct semantic segmentation results.
	 * The sphere is specified by its halfwidth and halfheight (radius).
	 * For technical reasons, the intensities must lie within a range from 0 to 255.
	 * In case multiple values have maximum frequency, the smallest one is returned.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius size along x axis. (default: 1)
	 * @param radius_y (float) - Radius size along y axis. (default: 1)
	 * @param radius_z (float) - Radius size along z axis. (default: 1)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ modeSphere(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.mode_sphere(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Computes the local mode of a pixels neighborhood.
	 * This neighborhood can be shaped as a box or a sphere.
	 * This can be used to postprocess and locally correct semantic segmentation results.
	 * The shape size is specified by its halfwidth, halfheight, and halfdepth (radius).
	 * For technical reasons, the intensities must lie within a range from 0 to 255 (uint8).
	 * In case multiple values have maximum frequency, the smallest one is returned.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius size along x axis. (default: 1)
	 * @param radius_y (float) - Radius size along y axis. (default: 1)
	 * @param radius_z (float) - Radius size along z axis. (default: 1)
	 * @param connectivity (String) - Filter neigborhood (default: "box")
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ mode(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.mode(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z, connectivity));
    }
    
	/**
	 * Computes the remainder of a division of pairwise pixel values in two images.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - First input image to process.
	 * @param input1 ({@link ArrayJ}) - Second input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ moduloImages(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.modulo_images(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Multiplies all pixel intensities with the x, y or z coordinate, depending on specified dimension.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param dimension (int) - Dimension (0,1,2) to use in the operation. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_multiplyImageAndCoordinate">reference_multiplyImageAndCoordinate</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ multiplyImageAndPosition(DeviceJ device, ArrayJ input, ArrayJ output, int dimension) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.multiply_image_and_position(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), dimension));
    }
    
	/**
	 * Multiplies all pixels value x in a given image X with a constant scalar s.
	 * &amp;lt;pre&amp;gt;f(x, s) = x * s&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - The input image to be multiplied with a constant.
	 * @param output ({@link ArrayJ}) - Output image where results are written into. (default: None)
	 * @param scalar (float) - The number with which every pixel will be multiplied with. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_multiplyImageAndScalar">reference_multiplyImageAndScalar</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ multiplyImageAndScalar(DeviceJ device, ArrayJ input, ArrayJ output, float scalar) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.multiply_image_and_scalar(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), scalar));
    }
    
	/**
	 * Multiplies all pairs of pixel values x and y from two image X and Y.
	 * &amp;lt;pre&amp;gt;f(x, y) = x * y&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - First input image to be multiplied.
	 * @param input1 ({@link ArrayJ}) - Second image to be multiplied.
	 * @param output ({@link ArrayJ}) - Output image where results are written into. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_multiplyImages">reference_multiplyImages</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ multiplyImages(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.multiply_images(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Copies all pixels instead those which are not a number (NaN), or positive/negative infinity which are replaced by a defined new value, default 0.
	 * This function aims to work similarly as its counterpart in numpy [1].
	 * Default values for posinf and neginf may differ from numpy and even differ depending on compute hardware.
	 * It is recommended to specify those values.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output image where results are written into. (default: None)
	 * @param nan (float) - Value to replace (default: 0)
	 * @param posinf (float) - Value to replace +inf with. (default: np.nan_to_num(float('inf')))
	 * @param neginf (float) - Value to replace -inf with. (default: np.nan_to_num(float('-inf')))
	 * @return {@link ArrayJ}
	 * @see <a href="https://numpy.org/doc/stable/reference/generated/numpy.nan_to_num.html">numpy.nan_to_num.html</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ nanToNum(DeviceJ device, ArrayJ input, ArrayJ output, float nan, float posinf, float neginf) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.nan_to_num(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), nan, posinf, neginf));
    }
    
	/**
	 * Apply a maximum filter (box shape) to the input image.
	 * The radius is fixed to 1 and pixels with value 0 are ignored.
	 * Note: Pixels with 0 value in the input image will not be overwritten in the output image.
	 * Thus, the result image should be initialized by copying the original image in advance.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output0 ({@link ArrayJ}) - Output flag (0 or 1).
	 * @param output1 ({@link ArrayJ}) - Output image where results are written into. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_nonzeroMaximumBox">reference_nonzeroMaximumBox</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ nonzeroMaximumBox(DeviceJ device, ArrayJ input, ArrayJ output0, ArrayJ output1) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.nonzero_maximum_box(device.getRaw(), input.getRaw(), output0.getRaw(), output1 == null ? null : output1.getRaw()));
    }
    
	/**
	 * Apply a maximum filter (diamond shape) to the input image.
	 * The radius is fixed to 1 and pixels with value 0 are ignored.
	 * Note: Pixels with 0 value in the input image will not be overwritten in the output image.
	 * Thus, the result image should be initialized by copying the original image in advance.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output0 ({@link ArrayJ}) - Output flag (0 or 1).
	 * @param output1 ({@link ArrayJ}) - Output image where results are written into. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_nonzeroMaximumDiamond">reference_nonzeroMaximumDiamond</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ nonzeroMaximumDiamond(DeviceJ device, ArrayJ input, ArrayJ output0, ArrayJ output1) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.nonzero_maximum_diamond(device.getRaw(), input.getRaw(), output0.getRaw(), output1 == null ? null : output1.getRaw()));
    }
    
	/**
	 * Apply a maximum filter of a neighborhood to the input image.
	 * The neighborhood shape can be a box or a sphere.
	 * The size is fixed to 1 and pixels with value 0 are ignored.
	 * Note: Pixels with 0 value in the input image will not be overwritten in the output image.
	 * Thus, the result image should be initialized by copying the original image in advance.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output0 ({@link ArrayJ}) - Output flag (0 or 1).
	 * @param output1 ({@link ArrayJ}) - Output image where results are written into. (default: None)
	 * @param connectivity (String) - Filter neigborhood (default: "box")
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_nonzeroMaximumBox">reference_nonzeroMaximumBox</a>
	 * @see <a href="https://clij.github.io/clij2-docs/reference_nonzeroMaximumDiamond">reference_nonzeroMaximumDiamond</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ nonzeroMaximum(DeviceJ device, ArrayJ input, ArrayJ output0, ArrayJ output1, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.nonzero_maximum(device.getRaw(), input.getRaw(), output0.getRaw(), output1 == null ? null : output1.getRaw(), connectivity));
    }
    
	/**
	 * Apply a minimum filter (box shape) to the input image.
	 * The radius is fixed to 1 and pixels with value 0 are ignored.
	 * Note: Pixels with 0 value in the input image will not be overwritten in the output image.
	 * Thus, the result image should be initialized by copying the original image in advance.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output0 ({@link ArrayJ}) - Output flag (0 or 1).
	 * @param output1 ({@link ArrayJ}) - Output image where results are written into. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_nonzeroMinimumBox">reference_nonzeroMinimumBox</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ nonzeroMinimumBox(DeviceJ device, ArrayJ input, ArrayJ output0, ArrayJ output1) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.nonzero_minimum_box(device.getRaw(), input.getRaw(), output0.getRaw(), output1 == null ? null : output1.getRaw()));
    }
    
	/**
	 * Apply a minimum filter (diamond shape) to the input image.
	 * The radius is fixed to 1 and pixels with value 0 are ignored.
	 * Note: Pixels with 0 value in the input image will not be overwritten in the output image.
	 * Thus, the result image should be initialized by copying the original image in advance.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output0 ({@link ArrayJ}) - Output flag (0 or 1).
	 * @param output1 ({@link ArrayJ}) - Output image where results are written into. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_nonzeroMinimumDiamond">reference_nonzeroMinimumDiamond</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ nonzeroMinimumDiamond(DeviceJ device, ArrayJ input, ArrayJ output0, ArrayJ output1) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.nonzero_minimum_diamond(device.getRaw(), input.getRaw(), output0.getRaw(), output1 == null ? null : output1.getRaw()));
    }
    
	/**
	 * Apply a minimum filter of a neighborhood to the input image.
	 * The neighborhood shape can be a box or a sphere.
	 * The radius is fixed to 1 and pixels with value 0 are ignored.
	 * Note: Pixels with 0 value in the input image will not be overwritten in the output image.
	 * Thus, the result image should be initialized by copying the original image in advance.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output0 ({@link ArrayJ}) - Output flag (0 or 1).
	 * @param output1 ({@link ArrayJ}) - Output image where results are written into. (default: None)
	 * @param connectivity (String) - Filter neigborhood (default: "box")
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_nonzeroMinimumBox">reference_nonzeroMinimumBox</a>
	 * @see <a href="https://clij.github.io/clij2-docs/reference_nonzeroMinimumDiamond">reference_nonzeroMinimumDiamond</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ nonzeroMinimum(DeviceJ device, ArrayJ input, ArrayJ output0, ArrayJ output1, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.nonzero_minimum(device.getRaw(), input.getRaw(), output0.getRaw(), output1 == null ? null : output1.getRaw(), connectivity));
    }
    
	/**
	 * Determines if two images A and B equal pixel wise.
	 * f(a, b) = 1 if a != b; 0 otherwise.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - First image to be compared with.
	 * @param input1 ({@link ArrayJ}) - Second image to be compared with the first.
	 * @param output ({@link ArrayJ}) - The resulting binary image where pixels will be 1 only if source1 (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_notEqual">reference_notEqual</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ notEqual(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.not_equal(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines if two images A and B equal pixel wise.
	 * f(a, b) = 1 if a != b; 0 otherwise.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - The image where every pixel is compared to the constant.
	 * @param output ({@link ArrayJ}) - The resulting binary image where pixels will be 1 only if source1 (default: None)
	 * @param scalar (float) - The constant where every pixel is compared to. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_notEqualConstant">reference_notEqualConstant</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ notEqualConstant(DeviceJ device, ArrayJ input, ArrayJ output, float scalar) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.not_equal_constant(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), scalar));
    }
    
	/**
	 * Pastes an image into another image at a given position.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param destination_x (int) - Origin pixel coodinate in x to paste. (default: 0)
	 * @param destination_y (int) - Origin pixel coodinate in y to paste. (default: 0)
	 * @param destination_z (int) - Origin pixel coodinate in z to paste. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_paste3D">reference_paste3D</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ paste(DeviceJ device, ArrayJ input, ArrayJ output, int destination_x, int destination_y, int destination_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.paste(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), destination_x, destination_y, destination_z));
    }
    
	/**
	 * Apply a local maximum filter to an image which only overwrites pixels with value 0.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param flag ({@link ArrayJ}) - Output
	 * @param output ({@link ArrayJ}) - Output image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_onlyzeroOverwriteMaximumBox">reference_onlyzeroOverwriteMaximumBox</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ onlyzeroOverwriteMaximumBox(DeviceJ device, ArrayJ input, ArrayJ flag, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.onlyzero_overwrite_maximum_box(device.getRaw(), input.getRaw(), flag.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Apply a local maximum filter to an image which only overwrites pixels with value 0.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param flag ({@link ArrayJ}) - Output
	 * @param output ({@link ArrayJ}) - Output image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_onlyzeroOverwriteMaximumDiamond">reference_onlyzeroOverwriteMaximumDiamond</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ onlyzeroOverwriteMaximumDiamond(DeviceJ device, ArrayJ input, ArrayJ flag, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.onlyzero_overwrite_maximum_diamond(device.getRaw(), input.getRaw(), flag.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Apply a local maximum filter to an image which only overwrites pixels with value 0.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param flag ({@link ArrayJ}) - Output
	 * @param output ({@link ArrayJ}) - Output image. (default: None)
	 * @param connectivity (String) - Filter neigborhood (default: "box")
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_onlyzeroOverwriteMaximumBox">reference_onlyzeroOverwriteMaximumBox</a>
	 * @see <a href="https://clij.github.io/clij2-docs/reference_onlyzeroOverwriteMaximumDiamond">reference_onlyzeroOverwriteMaximumDiamond</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ onlyzeroOverwriteMaximum(DeviceJ device, ArrayJ input, ArrayJ flag, ArrayJ output, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.onlyzero_overwrite_maximum(device.getRaw(), input.getRaw(), flag.getRaw(), output == null ? null : output.getRaw(), connectivity));
    }
    
	/**
	 * Computes all pixels value x to the power of a given exponent a.
	 * &amp;lt;pre&amp;gt;f(x, a) = x ^ a&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param scalar (float) - Power value. (default: 1)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_power">reference_power</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ power(DeviceJ device, ArrayJ input, ArrayJ output, float scalar) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.power(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), scalar));
    }
    
	/**
	 * Calculates x to the power of y pixel wise of two images X and Y.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - First input image to process.
	 * @param input1 ({@link ArrayJ}) - Second input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_powerImages">reference_powerImages</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ powerImages(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.power_images(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Crops an image according to a defined range and step size.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - First input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param start_x (int) - Range starting value in x (default: None)
	 * @param stop_x (int) - Range stop value in x (default: None)
	 * @param step_x (int) - Range step value in x (default: None)
	 * @param start_y (int) - Range starting value in y (default: None)
	 * @param stop_y (int) - Range stop value in y (default: None)
	 * @param step_y (int) - Range step value in y (default: None)
	 * @param start_z (int) - Range starting value in z (default: None)
	 * @param stop_z (int) - Range stop value in z (default: None)
	 * @param step_z (int) - Range step value in z (default: None)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ range(DeviceJ device, ArrayJ input, ArrayJ output, int start_x, int stop_x, int step_x, int start_y, int stop_y, int step_y, int start_z, int stop_z, int step_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.range(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), start_x, stop_x, step_x, start_y, stop_y, step_y, start_z, stop_z, step_z));
    }
    
	/**
	 * Go to positions in a given image specified by a pointlist and read intensities of those pixels.
	 * The intensities are stored in a new vector.
	 * The positions are passed as a (x,y,z) coordinate per column.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param list ({@link ArrayJ}) - List of coordinate, as a 2D matrix.
	 * @param output ({@link ArrayJ}) - Output vector image of intensities. (default: None)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ readValuesFromPositions(DeviceJ device, ArrayJ input, ArrayJ list, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
		Objects.requireNonNull(list, "list cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.read_values_from_positions(device.getRaw(), input.getRaw(), list.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Replaces integer intensities specified in a vector image.
	 * The values are passed as a vector of values.
	 * The vector index represents the old intensity and the value at that position represents the new intensity.
	 * s.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - Input image to process.
	 * @param input1 ({@link ArrayJ}) - List of intensities to replace, as a vector of values.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_replaceIntensities">reference_replaceIntensities</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ replaceValues(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.replace_values(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Replaces a specific intensity in an image with a given new value.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param value_to_replace (float) - Old value. (default: 0)
	 * @param value_replacement (float) - New value. (default: 1)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_replaceIntensity">reference_replaceIntensity</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ replaceValue(DeviceJ device, ArrayJ input, ArrayJ output, float value_to_replace, float value_replacement) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.replace_value(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), value_to_replace, value_replacement));
    }
    
	/**
	 * Replaces a specific intensity in an image with a given new value.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param value_to_replace (float) - Old value. (default: 0)
	 * @param value_replacement (float) - New value. (default: 1)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_replaceIntensity">reference_replaceIntensity</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ replaceIntensity(DeviceJ device, ArrayJ input, ArrayJ output, float value_to_replace, float value_replacement) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.replace_intensity(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), value_to_replace, value_replacement));
    }
    
	/**
	 * Replaces integer intensities specified in a vector image.
	 * The values are passed as a vector of values.
	 * The vector index represents the old intensity and the value at that position represents the new intensity.
	 * s.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - Input image to process.
	 * @param input1 ({@link ArrayJ}) - List of intensities to replace, as a vector of values.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_replaceIntensities">reference_replaceIntensities</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ replaceIntensities(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.replace_intensities(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes the local maximum of a pixels spherical neighborhood.
	 * The spheres size is specified by its halfwidth, halfheight and halfdepth (radius).
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius size along x axis. (default: 1)
	 * @param radius_y (float) - Radius size along y axis. (default: 1)
	 * @param radius_z (float) - Radius size along z axis. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_maximum3DSphere">reference_maximum3DSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ maximumSphere(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.maximum_sphere(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Computes the local minimum of a pixels spherical neighborhood.
	 * The spheres size is specified by its halfwidth, halfheight and halfdepth (radius).
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius size along x axis. (default: 1)
	 * @param radius_y (float) - Radius size along y axis. (default: 1)
	 * @param radius_z (float) - Radius size along z axis. (default: 1)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_minimum3DSphere">reference_minimum3DSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ minimumSphere(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.minimum_sphere(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Multiplies two matrices with each other.
	 * Shape of matrix1 should be equal to shape of matrix2 transposed.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param matrix1 ({@link ArrayJ}) - First matrix to process.
	 * @param matrix2 ({@link ArrayJ}) - Second matrix to process.
	 * @param matrix_destination ({@link ArrayJ}) - Output result matrix. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_multiplyMatrix">reference_multiplyMatrix</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ multiplyMatrix(DeviceJ device, ArrayJ matrix1, ArrayJ matrix2, ArrayJ matrix_destination) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(matrix1, "matrix1 cannot be null");
		Objects.requireNonNull(matrix2, "matrix2 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.multiply_matrix(device.getRaw(), matrix1.getRaw(), matrix2.getRaw(), matrix_destination == null ? null : matrix_destination.getRaw()));
    }
    
	/**
	 * Computes 1/x for every pixel value This function is supposed to work similarly to its counter part in numpy [1].
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://numpy.org/doc/stable/reference/generated/numpy.reciprocal.html">numpy.reciprocal.html</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ reciprocal(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.reciprocal(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Sets all pixel values x of a given image X to a constant value v.
	 * &amp;lt;pre&amp;gt;f(x) = v&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param scalar (float) - Value to set. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_set">reference_set</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ set(DeviceJ device, ArrayJ input, float scalar) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.set(device.getRaw(), input.getRaw(), scalar));
    }
    
	/**
	 * Sets all pixel values x of a given column in X to a constant value v.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param column_index (int) - Column index. (default: 0)
	 * @param value (float) - Value to set. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_setColumn">reference_setColumn</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ setColumn(DeviceJ device, ArrayJ input, int column_index, float value) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.set_column(device.getRaw(), input.getRaw(), column_index, value));
    }
    
	/**
	 * Sets all pixel values at the image border to a given value.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param value (float) - Value to set. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_setImageBorders">reference_setImageBorders</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ setImageBorders(DeviceJ device, ArrayJ input, float value) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.set_image_borders(device.getRaw(), input.getRaw(), value));
    }
    
	/**
	 * Sets all pixel values x of a given plane in X to a constant value v.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param plane_index (int) - Plane index. (default: 0)
	 * @param value (float) - Value to set. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_setPlane">reference_setPlane</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ setPlane(DeviceJ device, ArrayJ input, int plane_index, float value) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.set_plane(device.getRaw(), input.getRaw(), plane_index, value));
    }
    
	/**
	 * Sets all pixel values to their X coordinate.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_setRampX">reference_setRampX</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ setRampX(DeviceJ device, ArrayJ input) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.set_ramp_x(device.getRaw(), input.getRaw()));
    }
    
	/**
	 * Sets all pixel values to their Y coordinate.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_setRampY">reference_setRampY</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ setRampY(DeviceJ device, ArrayJ input) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.set_ramp_y(device.getRaw(), input.getRaw()));
    }
    
	/**
	 * Sets all pixel values to their Z coordinate.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_setRampZ">reference_setRampZ</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ setRampZ(DeviceJ device, ArrayJ input) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.set_ramp_z(device.getRaw(), input.getRaw()));
    }
    
	/**
	 * Sets all pixel values x of a given row in X to a constant value v.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param row_index (int) -  (default: 0)
	 * @param value (float) -  (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_setRow">reference_setRow</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ setRow(DeviceJ device, ArrayJ input, int row_index, float value) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.set_row(device.getRaw(), input.getRaw(), row_index, value));
    }
    
	/**
	 * Replaces all 0 value pixels in an image with the index of a pixel.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output image. (default: None)
	 * @param offset (int) - Offset value to start the indexing. (default: 1)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ setNonzeroPixelsToPixelindex(DeviceJ device, ArrayJ input, ArrayJ output, int offset) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.set_nonzero_pixels_to_pixelindex(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), offset));
    }
    
	/**
	 * Sets all pixel values a of a given image A to a constant value v in case its coordinates x == y.
	 * Otherwise the pixel is not overwritten.
	 * If you want to initialize an identity transfrom matrix, set all pixels to 0 first.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param value (float) - Value to set. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_setWhereXequalsY">reference_setWhereXequalsY</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ setWhereXEqualsY(DeviceJ device, ArrayJ input, float value) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.set_where_x_equals_y(device.getRaw(), input.getRaw(), value));
    }
    
	/**
	 * Sets all pixel values a of a given image A to a constant value v in case its coordinates x &amp;gt; y.
	 * Otherwise the pixel is not overwritten.
	 * If you want to initialize an identity transfrom matrix, set all pixels to 0 first.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param value (float) - Value to set. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_setWhereXgreaterThanY">reference_setWhereXgreaterThanY</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ setWhereXGreaterThanY(DeviceJ device, ArrayJ input, float value) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.set_where_x_greater_than_y(device.getRaw(), input.getRaw(), value));
    }
    
	/**
	 * Sets all pixel values a of a given image A to a constant value v in case its coordinates x &amp;lt; y.
	 * Otherwise the pixel is not overwritten.
	 * If you want to initialize an identity transfrom matrix, set all pixels to 0 first.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param value (float) - Value to set. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_setWhereXsmallerThanY">reference_setWhereXsmallerThanY</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ setWhereXSmallerThanY(DeviceJ device, ArrayJ input, float value) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.set_where_x_smaller_than_y(device.getRaw(), input.getRaw(), value));
    }
    
	/**
	 * Extracts the sign of pixels.
	 * If a pixel value &amp;lt; 0, resulting pixel value will be 1.
	 * If it was &amp;gt; 0, it will be 1.
	 * Otherwise it will be 0.
	 * This function aims to work similarly as its counterpart in numpy [1].
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ sign(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.sign(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines if two images A and B smaller pixel wise.
	 * f(a, b) = 1 if a &amp;lt; b; 0 otherwise.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - First input image to process.
	 * @param input1 ({@link ArrayJ}) - Second input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_smaller">reference_smaller</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ smaller(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.smaller(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines if two images A and B smaller pixel wise.
	 * f(a, b) = 1 if a &amp;lt; b; 0 otherwise.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param scalar (float) - Scalar used in the comparison. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_smallerConstant">reference_smallerConstant</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ smallerConstant(DeviceJ device, ArrayJ input, ArrayJ output, float scalar) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.smaller_constant(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), scalar));
    }
    
	/**
	 * Determines if two images A and B smaller or equal pixel wise.
	 * f(a, b) = 1 if a &amp;lt;= b; 0 otherwise.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - First input image to process.
	 * @param input1 ({@link ArrayJ}) - Second input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_smallerOrEqual">reference_smallerOrEqual</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ smallerOrEqual(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.smaller_or_equal(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines if two images A and B smaller or equal pixel wise.
	 * f(a, b) = 1 if a &amp;lt;= b; 0 otherwise.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param scalar (float) - Scalar used in the comparison. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_smallerOrEqualConstant">reference_smallerOrEqualConstant</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ smallerOrEqualConstant(DeviceJ device, ArrayJ input, ArrayJ output, float scalar) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.smaller_or_equal_constant(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), scalar));
    }
    
	/**
	 * Convolve the image with the Sobel kernel.
	 * Author(s): Ruth WhelanJeans, Robert Haase.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_sobel">reference_sobel</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ sobel(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.sobel(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes the square root of each pixel.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ squareRoot(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.square_root(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines the standard deviation intensity projection of an image stack along Z.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_standardDeviationZProjection">reference_standardDeviationZProjection</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ stdZProjection(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.std_z_projection(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Subtracts one image X from a scalar s pixel wise.
	 * &amp;lt;pre&amp;gt;f(x, s) = s x&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param scalar (float) - Scalar used in the subtraction. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_subtractImageFromScalar">reference_subtractImageFromScalar</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ subtractImageFromScalar(DeviceJ device, ArrayJ input, ArrayJ output, float scalar) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.subtract_image_from_scalar(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), scalar));
    }
    
	/**
	 * Takes an image and reduces it in width by factor blocksize.
	 * The new pixels contain the sum of the reduced pixels.
	 * For example, given the following image and block size 4: [0, 1, 1, 0, 1, 0, 1, 1] would lead to an image [2, 3].
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param blocksize (int) - Blocksize value. (default: 256)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ sumReductionX(DeviceJ device, ArrayJ input, ArrayJ output, int blocksize) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.sum_reduction_x(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), blocksize));
    }
    
	/**
	 * Determines the sum intensity projection of an image along Z.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_sumXProjection">reference_sumXProjection</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ sumXProjection(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.sum_x_projection(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines the sum intensity projection of an image along Z.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_sumYProjection">reference_sumYProjection</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ sumYProjection(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.sum_y_projection(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines the sum intensity projection of an image along Z.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_sumZProjection">reference_sumZProjection</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ sumZProjection(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.sum_z_projection(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Transpose X and Y axes of an image.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - The input image.
	 * @param output ({@link ArrayJ}) - Output image where results are written into. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_transposeXY">reference_transposeXY</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ transposeXy(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.transpose_xy(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Transpose X and Z axes of an image.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - The input image.
	 * @param output ({@link ArrayJ}) - Output image where results are written into. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_transposeXZ">reference_transposeXZ</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ transposeXz(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.transpose_xz(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Transpose Y and Z axes of an image.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - The input image.
	 * @param output ({@link ArrayJ}) - Output image where results are written into. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_transposeYZ">reference_transposeYZ</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ transposeYz(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.transpose_yz(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Copies all pixels instead those which are not a number (NaN) or infinity (inf), which are replaced by 0.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_undefinedToZero">reference_undefinedToZero</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ undefinedToZero(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.undefined_to_zero(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes the local variance of a pixels box neighborhood.
	 * The box size is specified by its halfwidth, halfheight and halfdepth (radius).
	 * If 2D images are given, radius_z will be ignored.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius size along x axis. (default: 1)
	 * @param radius_y (float) - Radius size along y axis. (default: 1)
	 * @param radius_z (float) - Radius size along z axis. (default: 1)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_varianceBox">reference_varianceBox</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ varianceBox(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.variance_box(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Computes the local variance of a pixels sphere neighborhood.
	 * The sphere size is specified by its halfwidth, halfheight and halfdepth (radius).
	 * If 2D images are given, radius_z will be ignored.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius size along x axis. (default: 1)
	 * @param radius_y (float) - Radius size along y axis. (default: 1)
	 * @param radius_z (float) - Radius size along z axis. (default: 1)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_varianceSphere">reference_varianceSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ varianceSphere(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.variance_sphere(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Computes the local variance of a pixels neighborhood (box or sphere).
	 * The neighborhood size is specified by its halfwidth, halfheight and halfdepth (radius).
	 * If 2D images are given, radius_z will be ignored.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius size along x axis. (default: 1)
	 * @param radius_y (float) - Radius size along y axis. (default: 1)
	 * @param radius_z (float) - Radius size along z axis. (default: 1)
	 * @param connectivity (String) - Filter neigborhood (default: "box")
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_varianceBox">reference_varianceBox</a>
	 * @see <a href="https://clij.github.io/clij2-docs/reference_varianceSphere">reference_varianceSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ varianceFilter(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.variance_filter(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z, connectivity));
    }
    
	/**
	 * Takes an image with three/four rows (2D: height = 3; 3D: height = 4): x, y [, z] and v and target image.
	 * The value v will be written at position x/y[/z] in the target image.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_writeValuesToPositions">reference_writeValuesToPositions</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ writeValuesToPositions(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.write_values_to_positions(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines an Xposition of the maximum intensity along X and writes it into the resulting image.
	 * If there are multiple xslices with the same value, the smallest X will be chosen.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image stack
	 * @param output ({@link ArrayJ}) - altitude map (default: None)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ xPositionOfMaximumXProjection(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.x_position_of_maximum_x_projection(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines an Xposition of the minimum intensity along X and writes it into the resulting image.
	 * If there are multiple xslices with the same value, the smallest X will be chosen.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image stack
	 * @param output ({@link ArrayJ}) - altitude map (default: None)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ xPositionOfMinimumXProjection(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.x_position_of_minimum_x_projection(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines an Yposition of the maximum intensity along Y and writes it into the resulting image.
	 * If there are multiple yslices with the same value, the smallest Y will be chosen.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image stack
	 * @param output ({@link ArrayJ}) - altitude map (default: None)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ yPositionOfMaximumYProjection(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.y_position_of_maximum_y_projection(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines an Yposition of the minimum intensity along Y and writes it into the resulting image.
	 * If there are multiple yslices with the same value, the smallest Y will be chosen.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image stack
	 * @param output ({@link ArrayJ}) - altitude map (default: None)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ yPositionOfMinimumYProjection(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.y_position_of_minimum_y_projection(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines a Zposition of the maximum intensity along Z and writes it into the resulting image.
	 * If there are multiple zslices with the same value, the smallest Z will be chosen.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image stack
	 * @param output ({@link ArrayJ}) - altitude map (default: None)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ zPositionOfMaximumZProjection(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.z_position_of_maximum_z_projection(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines a Zposition of the minimum intensity along Z and writes it into the resulting image.
	 * If there are multiple zslices with the same value, the smallest Z will be chosen.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image stack
	 * @param output ({@link ArrayJ}) - altitude map (default: None)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ zPositionOfMinimumZProjection(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier1.z_position_of_minimum_z_projection(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
}
