
/**
 * This file is autogenerated. Do not edit manually.
 */    
package net.clesperanto.kernels;

import java.util.Objects;
import java.util.ArrayList;
import java.util.HashMap;

import net.clesperanto.core.ArrayJ;
import net.clesperanto.core.DeviceJ;
import net.clesperanto.core.Utils;

/**
 * Class containing all functions of tier 2 category
 */
public class Tier2 {

	/**
	 * Determines the absolute difference, pixel-by-pixel, between two images.
	 * &amp;lt;pre&amp;gt;f(x, y) = |x - y|&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - The input image to be subtracted from.
	 * @param input1 ({@link ArrayJ}) - The input image which is subtracted.
	 * @param output ({@link ArrayJ}) - The output image where results are written into. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_absoluteDifference">reference_absoluteDifference</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ absoluteDifference(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.absolute_difference(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Calculates the sum of pairs of pixels x and y of two images X and Y.
	 * &amp;lt;pre&amp;gt;f(x, y) = x + y&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - The first input image to be added.
	 * @param input1 ({@link ArrayJ}) - The second image to be added.
	 * @param output ({@link ArrayJ}) - The output image where results are written into. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_addImages">reference_addImages</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ addImages(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.add_images(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Applies a bottom-hat filter for background subtraction to the input image.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - The input image where the background is subtracted from.
	 * @param output ({@link ArrayJ}) - The output image where results are written into. (default: None)
	 * @param radius_x (float) - Radius of the background determination region in X. (default: 1)
	 * @param radius_y (float) - Radius of the background determination region in Y. (default: 1)
	 * @param radius_z (float) - Radius of the background determination region in Z. (default: 1)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_bottomHatBox">reference_bottomHatBox</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ bottomHatBox(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.bottom_hat_box(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Applies a bottom-hat filter for background subtraction to the input image.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - The input image where the background is subtracted from.
	 * @param output ({@link ArrayJ}) - The output image where results are written into. (default: None)
	 * @param radius_x (float) - Radius of the background determination region in X. (default: 1)
	 * @param radius_y (float) - Radius of the background determination region in Y. (default: 1)
	 * @param radius_z (float) - Radius of the background determination region in Z. (default: 1)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_bottomHatSphere">reference_bottomHatSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ bottomHatSphere(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.bottom_hat_sphere(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Applies a bottom-hat filter for background subtraction to the input image.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - The input image where the background is subtracted from.
	 * @param output ({@link ArrayJ}) - The output image where results are written into. (default: None)
	 * @param radius_x (float) - Radius of the background determination region in X. (default: 1)
	 * @param radius_y (float) - Radius of the background determination region in Y. (default: 1)
	 * @param radius_z (float) - Radius of the background determination region in Z. (default: 1)
	 * @param connectivity (String) - Element shape, "box" or "sphere". (default: "box")
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_bottomHatBox">reference_bottomHatBox</a>
	 * @see <a href="https://clij.github.io/clij2-docs/reference_bottomHatSphere">reference_bottomHatSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ bottomHat(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.bottom_hat(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z, connectivity));
    }
    
	/**
	 * Limits the range of values in an image.
	 * This function works similarly to its counterpart in NumPy.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output image. (default: None)
	 * @param min_intensity (float) - New lower limit of the intensity range. (default: None)
	 * @param max_intensity (float) - New upper limit of the intensity range. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://numpy.org/doc/stable/reference/generated/numpy.clip.html">numpy.clip.html</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ clip(DeviceJ device, ArrayJ input, ArrayJ output, float min_intensity, float max_intensity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.clip(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), min_intensity, max_intensity));
    }
    
	/**
	 * Closing operator, applies grayscale morphological closing to intensity images using a box-shaped footprint.
	 * This operator also works with binary images.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius along the x axis. (default: 1)
	 * @param radius_y (float) - Radius along the y axis. (default: 1)
	 * @param radius_z (float) - Radius along the z axis. (default: 1)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ closingBox(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.closing_box(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Closing operator, applies grayscale morphological closing to intensity images using a sphere-shaped footprint.
	 * This operator also works with binary images.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius along the x axis. (default: 1)
	 * @param radius_y (float) - Radius along the y axis. (default: 1)
	 * @param radius_z (float) - Radius along the z axis. (default: 1)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ closingSphere(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.closing_sphere(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Closing operator, applies grayscale morphological closing to intensity images using a box- or sphere-shaped footprint.
	 * This operator also works with binary images.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius along the x axis. (default: 1)
	 * @param radius_y (float) - Radius along the y axis. (default: 1)
	 * @param radius_z (float) - Radius along the z axis. (default: 1)
	 * @param connectivity (String) - Element shape, "box" or "sphere" (default: "box")
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ grayscaleClosing(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.grayscale_closing(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z, connectivity));
    }
    
	/**
	 * Closing operator, applies morphological closing to intensity images using a custom structuring element provided as input.
	 * This operator also works with binary images.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param footprint ({@link ArrayJ}) - Structuring element for the operation.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ closing(DeviceJ device, ArrayJ input, ArrayJ footprint, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
		Objects.requireNonNull(footprint, "footprint cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.closing(device.getRaw(), input.getRaw(), footprint.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Closing operator, applies binary morphological closing to intensity images using a sphere- or box-shaped footprint.
	 * This operator also works with binary images.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius of the sphere or box element along the x axis. (default: 1)
	 * @param radius_y (float) - Radius of the sphere or box element along the y axis. (default: 1)
	 * @param radius_z (float) - Radius of the sphere or box element along the z axis. (default: 1)
	 * @param connectivity (String) - Element shape, "box" or "sphere" (default: "box")
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ binaryClosing(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.binary_closing(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z, connectivity));
    }
    
	/**
	 * Concatenates two images or stacks along the x axis.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - First input image.
	 * @param input1 ({@link ArrayJ}) - Second input image.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_combineHorizontally">reference_combineHorizontally</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ concatenateAlongX(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.concatenate_along_x(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Concatenates two images or stacks along the y axis.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - First input image.
	 * @param input1 ({@link ArrayJ}) - Second input image.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_combineVertically">reference_combineVertically</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ concatenateAlongY(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.concatenate_along_y(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Concatenates two images or stacks along the z axis.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - First input image.
	 * @param input1 ({@link ArrayJ}) - Second input image.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_concatenateStacks">reference_concatenateStacks</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ concatenateAlongZ(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.concatenate_along_z(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Takes a touch matrix as input and returns a vector containing the number of touching neighbors per label.
	 * Note: Background is considered touchable.
	 * To ignore touches with the background, pass a touch matrix where the first column (index = 0) is set to 0.
	 * Use set_column for that.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param touch_matrix ({@link ArrayJ}) - Input touch matrix to process.
	 * @param touching_neighbors_count_destination ({@link ArrayJ}) - Output vector of touch count. (default: None)
	 * @param ignore_background (boolean) -  (default: True)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_countTouchingNeighbors">reference_countTouchingNeighbors</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ countTouchingNeighbors(DeviceJ device, ArrayJ touch_matrix, ArrayJ touching_neighbors_count_destination, boolean ignore_background) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(touch_matrix, "touch_matrix cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.count_touching_neighbors(device.getRaw(), touch_matrix.getRaw(), touching_neighbors_count_destination == null ? null : touching_neighbors_count_destination.getRaw(), ignore_background));
    }
    
	/**
	 * Crops an image by removing the outer pixels (default: 1).
	 * To ensure the output image has the expected size, set dst = None.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param border_size (int) - Border size to crop. (default: 1)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ cropBorder(DeviceJ device, ArrayJ input, ArrayJ output, int border_size) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.crop_border(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), border_size));
    }
    
	/**
	 * Applies Gaussian blur to the input image and divides the original by the result.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param sigma_x (float) - Gaussian sigma value along x. (default: 2)
	 * @param sigma_y (float) - Gaussian sigma value along y. (default: 2)
	 * @param sigma_z (float) - Gaussian sigma value along z. (default: 2)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_divideByGaussianBackground">reference_divideByGaussianBackground</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ divideByGaussianBackground(DeviceJ device, ArrayJ input, ArrayJ output, float sigma_x, float sigma_y, float sigma_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.divide_by_gaussian_background(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), sigma_x, sigma_y, sigma_z));
    }
    
	/**
	 * Converts degrees to radians.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ degreesToRadians(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.degrees_to_radians(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Detects local maxima in a given square/cubic neighborhood.
	 * Pixels in the resulting image are set to 1 if there is no other pixel in a given radius which has a higher intensity, and to 0 otherwise.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius along the x axis. (default: 0)
	 * @param radius_y (float) - Radius along the y axis. (default: 0)
	 * @param radius_z (float) - Radius along the z axis. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_detectMaximaBox">reference_detectMaximaBox</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ detectMaximaBox(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.detect_maxima_box(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Detects local maxima in a given square/cubic neighborhood.
	 * Pixels in the resulting image are set to 1 if there is no other pixel in a given radius which has a higher intensity, and to 0 otherwise.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius along the x axis. (default: 0)
	 * @param radius_y (float) - Radius along the y axis. (default: 0)
	 * @param radius_z (float) - Radius along the z axis. (default: 0)
	 * @param connectivity (String) - Element shape, "box" or "sphere" (default: "box")
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_detectMaximaBox">reference_detectMaximaBox</a>
	 * @see <a href="https://clij.github.io/clij2-docs/reference_detectMaximaSphere">reference_detectMaximaSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ detectMaxima(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.detect_maxima(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z, connectivity));
    }
    
	/**
	 * Detects local minima in a given square/cubic neighborhood.
	 * Pixels in the resulting image are set to 1 if there is no other pixel in a given radius which has a lower intensity, and to 0 otherwise.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius along the x axis. (default: 0)
	 * @param radius_y (float) - Radius along the y axis. (default: 0)
	 * @param radius_z (float) - Radius along the z axis. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_detectMinimaBox">reference_detectMinimaBox</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ detectMinimaBox(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.detect_minima_box(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Detects local minima in a given square/cubic neighborhood.
	 * Pixels in the resulting image are set to 1 if there is no other pixel in a given radius which has a lower intensity, and to 0 otherwise.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius along the x axis. (default: 0)
	 * @param radius_y (float) - Radius along the y axis. (default: 0)
	 * @param radius_z (float) - Radius along the z axis. (default: 0)
	 * @param connectivity (String) - Element shape, "box" or "sphere" (default: "box")
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_detectMinimaBox">reference_detectMinimaBox</a>
	 * @see <a href="https://clij.github.io/clij2-docs/reference_detectMinimaSphere">reference_detectMinimaSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ detectMinima(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.detect_minima(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z, connectivity));
    }
    
	/**
	 * Applies Gaussian blur to the input image twice with different sigma values, producing two images, one of which is subtracted from the other.
	 * It is recommended to apply this operation to images of type float (32-bit) because results might be negative.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - The input image to be processed.
	 * @param output ({@link ArrayJ}) - The output image where results are written into. (default: None)
	 * @param sigma1_x (float) - Sigma of the first Gaussian filter in x (default: 2)
	 * @param sigma1_y (float) - Sigma of the first Gaussian filter in y (default: 2)
	 * @param sigma1_z (float) - Sigma of the first Gaussian filter in z (default: 2)
	 * @param sigma2_x (float) - Sigma of the second Gaussian filter in x (default: 2)
	 * @param sigma2_y (float) - Sigma of the second Gaussian filter in y (default: 2)
	 * @param sigma2_z (float) - Sigma of the second Gaussian filter in z (default: 2)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_differenceOfGaussian3D">reference_differenceOfGaussian3D</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ differenceOfGaussian(DeviceJ device, ArrayJ input, ArrayJ output, float sigma1_x, float sigma1_y, float sigma1_z, float sigma2_x, float sigma2_y, float sigma2_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.difference_of_gaussian(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), sigma1_x, sigma1_y, sigma1_z, sigma2_x, sigma2_y, sigma2_z));
    }
    
	/**
	 * Takes a label map image and dilates the regions using an octagon shape until they touch.
	 * The resulting label map is written to the output.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_extendLabelingViaVoronoi">reference_extendLabelingViaVoronoi</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ extendLabelingViaVoronoi(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.extend_labeling_via_voronoi(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes the negative value of all pixels in a given image.
	 * It is recommended to convert images to 32-bit float before applying this operation.
	 * &amp;lt;pre&amp;gt;f(x) = -x&amp;lt;/pre&amp;gt; For binary images, use binaryNot.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_invert">reference_invert</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ invert(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.invert(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Transforms a binary image with single pixels set to 1 into a labeled spots image.
	 * Converts a spots image (e.
	 * g.
	 * , from maxima/minima detection) into a label image of the same size, assigning IDs 1, 2, â€¦, n.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_labelSpots">reference_labelSpots</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ labelSpots(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.label_spots(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines the Hessian eigenvalues and returns the large eigenvalue image.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ largeHessianEigenvalue(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.large_hessian_eigenvalue(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines the maximum of all pixels in a given image.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @return float
	 * @see <a href="https://clij.github.io/clij2-docs/reference_maximumOfAllPixels">reference_maximumOfAllPixels</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static float maximumOfAllPixels(DeviceJ device, ArrayJ input) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return net.clesperanto._internals.kernelj.Tier2.maximum_of_all_pixels(device.getRaw(), input.getRaw());
    }
    
	/**
	 * Determines the minimum of all pixels in a given image.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @return float
	 * @see <a href="https://clij.github.io/clij2-docs/reference_minimumOfAllPixels">reference_minimumOfAllPixels</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static float minimumOfAllPixels(DeviceJ device, ArrayJ input) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return net.clesperanto._internals.kernelj.Tier2.minimum_of_all_pixels(device.getRaw(), input.getRaw());
    }
    
	/**
	 * Determines the minimum intensity in a masked image, but only over pixels that have nonzero values in a separate mask image.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param mask ({@link ArrayJ}) - Input
	 * @return float
	 * @see <a href="https://clij.github.io/clij2-docs/reference_minimumOfMaskedPixels">reference_minimumOfMaskedPixels</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static float minimumOfMaskedPixels(DeviceJ device, ArrayJ input, ArrayJ mask) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
		Objects.requireNonNull(mask, "mask cannot be null");
        return net.clesperanto._internals.kernelj.Tier2.minimum_of_masked_pixels(device.getRaw(), input.getRaw(), mask.getRaw());
    }
    
	/**
	 * Opening operator, applies morphological opening to intensity images using a box-shaped footprint.
	 * This operator also works with binary images.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius along the x axis. (default: 1)
	 * @param radius_y (float) - Radius along the y axis. (default: 1)
	 * @param radius_z (float) - Radius along the z axis. (default: 1)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ openingBox(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.opening_box(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Opening operator, applies morphological opening to intensity images using a sphere-shaped footprint.
	 * This operator also works with binary images.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius along the x axis. (default: 1)
	 * @param radius_y (float) - Radius along the y axis. (default: 1)
	 * @param radius_z (float) - Radius along the z axis. (default: 1)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ openingSphere(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.opening_sphere(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Opening operator, applies morphological opening to intensity images using a sphere- or box-shaped footprint.
	 * This operator also works with binary images.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius along the x axis. (default: 1)
	 * @param radius_y (float) - Radius along the y axis. (default: 1)
	 * @param radius_z (float) - Radius along the z axis. (default: 1)
	 * @param connectivity (String) - Element shape, "box" or "sphere" (default: "box")
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ grayscaleOpening(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.grayscale_opening(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z, connectivity));
    }
    
	/**
	 * Opening operator, applies morphological opening to intensity images using a custom structuring element provided as input.
	 * This operator also works with binary images.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param footprint ({@link ArrayJ}) - Structuring element for the operation.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ opening(DeviceJ device, ArrayJ input, ArrayJ footprint, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
		Objects.requireNonNull(footprint, "footprint cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.opening(device.getRaw(), input.getRaw(), footprint.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Opening operator, applies binary morphological opening to intensity images using a sphere- or box-shaped footprint.
	 * This operator also works with binary images.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius of the sphere or box element along the x axis. (default: 1)
	 * @param radius_y (float) - Radius of the sphere or box element along the y axis. (default: 1)
	 * @param radius_z (float) - Radius of the sphere or box element along the z axis. (default: 1)
	 * @param connectivity (String) - Element shape, "box" or "sphere" (default: "box")
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ binaryOpening(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.binary_opening(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z, connectivity));
    }
    
	/**
	 * Converts radians to degrees.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ radiansToDegrees(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.radians_to_degrees(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Takes a label map and reduces all labels to their edges.
	 * Label IDs stay and background will be zero.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_reduceLabelsToLabelEdges">reference_reduceLabelsToLabelEdges</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ reduceLabelsToLabelEdges(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.reduce_labels_to_label_edges(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines the Hessian eigenvalues and returns the small eigenvalue image.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ smallHessianEigenvalue(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.small_hessian_eigenvalue(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Returns the element-wise square of the input.
	 * This function is similar to its counterpart in NumPy.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://numpy.org/doc/stable/reference/generated/numpy.square.html">numpy.square.html</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ square(DeviceJ device, ArrayJ input, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.square(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Determines the squared difference pixel by pixel between two images.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - First input image.
	 * @param input1 ({@link ArrayJ}) - Second input image.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_squaredDifference">reference_squaredDifference</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ squaredDifference(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.squared_difference(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Computes the local standard deviation of each pixel's box neighborhood.
	 * The box size is specified by its half-width, half-height, and half-depth (radius).
	 * If 2D images are given, radius_z will be ignored.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius along the x axis. (default: 1)
	 * @param radius_y (float) - Radius along the y axis. (default: 1)
	 * @param radius_z (float) - Radius along the z axis. (default: 1)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_standardDeviationBox">reference_standardDeviationBox</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ standardDeviationBox(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.standard_deviation_box(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Computes the local standard deviation of each pixel's spherical neighborhood.
	 * The neighborhood size is specified by its half-width, half-height, and half-depth (radius).
	 * If 2D images are given, radius_z will be ignored.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius along the x axis. (default: 1)
	 * @param radius_y (float) - Radius along the y axis. (default: 1)
	 * @param radius_z (float) - Radius along the z axis. (default: 1)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_standardDeviationSphere">reference_standardDeviationSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ standardDeviationSphere(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.standard_deviation_sphere(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Computes the local standard deviation of each pixel's neighborhood.
	 * The neighborhood size is specified by its half-width, half-height, and half-depth (radius).
	 * If 2D images are given, radius_z will be ignored.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Radius along the x axis. (default: 1)
	 * @param radius_y (float) - Radius along the y axis. (default: 1)
	 * @param radius_z (float) - Radius along the z axis. (default: 1)
	 * @param connectivity (String) - Neighborhood shape, "box" or "sphere". (default: "box")
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_standardDeviationBox">reference_standardDeviationBox</a>
	 * @see <a href="https://clij.github.io/clij2-docs/reference_standardDeviationSphere">reference_standardDeviationSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ standardDeviation(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.standard_deviation(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z, connectivity));
    }
    
	/**
	 * Applies Gaussian blur to the input image and subtracts the result from the original.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param sigma_x (float) - Gaussian sigma value along x. (default: 2)
	 * @param sigma_y (float) - Gaussian sigma value along y. (default: 2)
	 * @param sigma_z (float) - Gaussian sigma value along z. (default: 2)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_subtractGaussianBackground">reference_subtractGaussianBackground</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ subtractGaussianBackground(DeviceJ device, ArrayJ input, ArrayJ output, float sigma_x, float sigma_y, float sigma_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.subtract_gaussian_background(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), sigma_x, sigma_y, sigma_z));
    }
    
	/**
	 * Subtracts one image X from another image Y pixel-wise.
	 * &amp;lt;pre&amp;gt;f(x, y) = x - y&amp;lt;/pre&amp;gt;.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input0 ({@link ArrayJ}) - First input image.
	 * @param input1 ({@link ArrayJ}) - Second input image.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_subtractImages">reference_subtractImages</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ subtractImages(DeviceJ device, ArrayJ input0, ArrayJ input1, ArrayJ output) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input0, "input0 cannot be null");
		Objects.requireNonNull(input1, "input1 cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.subtract_images(device.getRaw(), input0.getRaw(), input1.getRaw(), output == null ? null : output.getRaw()));
    }
    
	/**
	 * Crop a volume into a new volume, along the z-axis.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image.
	 * @param output ({@link ArrayJ}) - Output image. (default: None)
	 * @param start_z (int) - Start z coordinate of the crop. (default: 0)
	 * @param end_z (int) - End z coordinate of the crop. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_subStack">reference_subStack</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ subStack(DeviceJ device, ArrayJ input, ArrayJ output, int start_z, int end_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.sub_stack(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), start_z, end_z));
    }
    
	/**
	 * Reduces the number of z-slices in a stack by a given factor.
	 * With the offset you have control over which slices stay: with factor 3 and offset 0, slices 0, 3, 6, â€¦ are kept; with factor 4 and offset 1, slices 1, 5, 9, â€¦ are kept.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image.
	 * @param output ({@link ArrayJ}) - Output image. (default: None)
	 * @param reduction_factor (int) - Reduction factor. (default: 2)
	 * @param offset (int) - Offset. (default: 0)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_reduceStack">reference_reduceStack</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ reduceStack(DeviceJ device, ArrayJ input, ArrayJ output, int reduction_factor, int offset) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.reduce_stack(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), reduction_factor, offset));
    }
    
	/**
	 * Determines the sum of all pixels in a given image.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process. (default: None)
	 * @return float
	 * @see <a href="https://clij.github.io/clij2-docs/reference_sumOfAllPixels">reference_sumOfAllPixels</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static float sumOfAllPixels(DeviceJ device, ArrayJ input) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return net.clesperanto._internals.kernelj.Tier2.sum_of_all_pixels(device.getRaw(), input == null ? null : input.getRaw());
    }
    
	/**
	 * Applies a top-hat filter for background subtraction to the input image.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - The input image where the background is subtracted from.
	 * @param output ({@link ArrayJ}) - The output image where results are written into. (default: None)
	 * @param radius_x (float) - Radius of the background determination region in X. (default: 1)
	 * @param radius_y (float) - Radius of the background determination region in Y. (default: 1)
	 * @param radius_z (float) - Radius of the background determination region in Z. (default: 1)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_topHatBox">reference_topHatBox</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ topHatBox(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.top_hat_box(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Applies a top-hat filter for background subtraction to the input image.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - The input image where the background is subtracted from.
	 * @param output ({@link ArrayJ}) - The output image where results are written into. (default: None)
	 * @param radius_x (float) - Radius of the background determination region in X. (default: 1)
	 * @param radius_y (float) - Radius of the background determination region in Y. (default: 1)
	 * @param radius_z (float) - Radius of the background determination region in Z. (default: 1)
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_topHatSphere">reference_topHatSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
	@Deprecated
    public static ArrayJ topHatSphere(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.top_hat_sphere(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z));
    }
    
	/**
	 * Applies a top-hat filter for background subtraction to the input image.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - The input image where the background is subtracted from.
	 * @param output ({@link ArrayJ}) - The output image where results are written into. (default: None)
	 * @param radius_x (float) - Radius of the background determination region in X. (default: 1)
	 * @param radius_y (float) - Radius of the background determination region in Y. (default: 1)
	 * @param radius_z (float) - Radius of the background determination region in Z. (default: 1)
	 * @param connectivity (String) - Element shape, "box" or "sphere" (default: "box")
	 * @return {@link ArrayJ}
	 * @see <a href="https://clij.github.io/clij2-docs/reference_topHatBox">reference_topHatBox</a>
	 * @see <a href="https://clij.github.io/clij2-docs/reference_topHatSphere">reference_topHatSphere</a>
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ topHat(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float radius_z, String connectivity) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.top_hat(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, radius_z, connectivity));
    }
    
	/**
	 * Depth projection using the local variance maxima to determine the best focus plane.
	 * The radius parameter controls the local variance calculation, and sigma applies a Gaussian blur for smoothness of the projection.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param radius_x (float) - Neighborhood radius along the x axis. (default: 10)
	 * @param radius_y (float) - Neighborhood radius along the y axis. (default: 10)
	 * @param sigma (float) - Sigma for Gaussian blur. (default: 5)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ extendedDepthOfFocusVarianceProjection(DeviceJ device, ArrayJ input, ArrayJ output, float radius_x, float radius_y, float sigma) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.extended_depth_of_focus_variance_projection(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), radius_x, radius_y, sigma));
    }
    
	/**
	 * Depth projection using the local Sobel gradient magnitude maxima to determine the best focus plane.
	 * Sigma applies a Gaussian blur for smoothness of the projection.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param output ({@link ArrayJ}) - Output result image. (default: None)
	 * @param sigma (float) - Sigma for Gaussian blur. (default: 5)
	 * @return {@link ArrayJ}
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayJ extendedDepthOfFocusSobelProjection(DeviceJ device, ArrayJ input, ArrayJ output, float sigma) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return new ArrayJ(net.clesperanto._internals.kernelj.Tier2.extended_depth_of_focus_sobel_projection(device.getRaw(), input.getRaw(), output == null ? null : output.getRaw(), sigma));
    }
    
	/**
	 * Determines the Hessian matrix eigenvalues using the Gaussian-derivative method and returns the small, middle and large eigenvalue images.
	 * The function returns the list of eigenvalues as images, in decreasing order.
	 * The first image is the largest eigenvalue.
	 * @param device ({@link DeviceJ}) - Device to perform the operation on.
	 * @param input ({@link ArrayJ}) - Input image to process.
	 * @param small_eigenvalue ({@link ArrayJ}) - Output result image for the small eigenvalue. (default: None)
	 * @param middle_eigenvalue ({@link ArrayJ}) - Output result image for the middle eigenvalue. (default: None)
	 * @param large_eigenvalue ({@link ArrayJ}) - Output result image for the large eigenvalue. (default: None)
	 * @param sigma (float) - Sigma of the Gaussian kernel. (default: 1)
	 * @return ArrayList&amp;lt;{@link ArrayJ}&amp;gt;
	 * @throws NullPointerException if any of the device or input parameters are null.
	 */
    public static ArrayList<ArrayJ> hessianGaussianEigenvalues(DeviceJ device, ArrayJ input, ArrayJ small_eigenvalue, ArrayJ middle_eigenvalue, ArrayJ large_eigenvalue, float sigma) {
        Objects.requireNonNull(device, "device cannot be null");
		Objects.requireNonNull(input, "input cannot be null");
        return Utils.toArrayList(net.clesperanto._internals.kernelj.Tier2.hessian_gaussian_eigenvalues(device.getRaw(), input.getRaw(), small_eigenvalue == null ? null : small_eigenvalue.getRaw(), middle_eigenvalue == null ? null : middle_eigenvalue.getRaw(), large_eigenvalue == null ? null : large_eigenvalue.getRaw(), sigma));
    }
    
}
